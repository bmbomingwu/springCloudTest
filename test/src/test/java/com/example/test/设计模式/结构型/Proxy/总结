应用场景：

保护目标对象。
增强目标对象。
优点：

代理模式能将代理对象与真实被调用的目标对象分离。
一定程度上降低了系统的耦合程度，易于扩展。
代理可以起到保护目标对象的作用。
增强目标对象的职责。
缺点：

代理模式会造成系统设计中类的数目增加。
在客户端和目标对象之间增加了一个代理对象，请求处理速度变慢。
增加了系统的复杂度。
两种动态代理的对比：

JDK动态代理的特点：
需要实现InvocationHandler接口， 并重写invoke方法。
被代理类需要实现接口， 它不支持继承。
JDK 动态代理类不需要事先定义好， 而是在运行期间动态生成。
JDK 动态代理不需要实现和被代理类一样的接口， 所以可以绑定多个被代理类。
主要实现原理为反射， 它通过反射在运行期间动态生成代理类， 并且通过反射调用被代理类的实际业务方法。
cglib的特点：
cglib动态代理中使用的是FastClass机制。
cglib生成字节码的底层原理是使用ASM字节码框架。
cglib动态代理需创建3份字节码，所以在第一次使用时会比较耗性能，但是后续使用较JDK动态代理方式更高效，适合单例bean场景。
cglib由于是采用动态创建子类的方法，对于final方法，无法进行代理。
